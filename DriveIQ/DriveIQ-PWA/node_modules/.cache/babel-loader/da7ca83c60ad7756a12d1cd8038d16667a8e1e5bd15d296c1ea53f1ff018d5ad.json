{"ast":null,"code":"import api from './api'; // Axios instance\n\n// Helper to send a batch of GPS data to the backend\nconst sendGPSBatchToBackend = async (batch, driverId) => {\n  try {\n    const token = localStorage.getItem('token'); // Get JWT token\n    if (!token) {\n      console.error('No token found');\n      return;\n    }\n    const response = await api.post('/record-telematics', {\n      driver_id: driverId,\n      gps_data: batch // Send the batch data\n    }, {\n      headers: {\n        Authorization: `Bearer ${token}`\n      }\n    });\n    if (response.status === 200) {\n      console.log('Batch successfully sent:', response.data);\n    } else {\n      console.error('Error sending GPS data. Response:', response);\n    }\n  } catch (error) {\n    console.error('Error sending GPS data:', error.response || error.message || error);\n  }\n};\n\n// Function to generate random time steps between 60 and 300 seconds\nconst generateRandomTimeStep = () => {\n  return Math.floor(Math.random() * (300 - 60 + 1)) + 60;\n};\n\n// Function to generate random lat/long points near a base point\nconst generateRandomLatLng = (baseLat, baseLng, distance = 0.01) => {\n  const randomOffset = () => (Math.random() - 0.5) * distance; // Generate small random offset for lat/lng\n  return {\n    Latitude: baseLat + randomOffset(),\n    Longitude: baseLng + randomOffset()\n  };\n};\n\n// Function to calculate speed in km/h between two GPS points based on distance and time step\nconst calculateSpeed = (point1, point2, timeStep) => {\n  if (timeStep === 0) return NaN; // Avoid division by zero\n\n  const distance = calculateDistance(point1, point2); // Distance in meters\n  let speed = distance / timeStep * 3.6; // Convert m/s to km/h\n\n  // Cap the speed to a realistic value (e.g., max 200 km/h)\n  if (speed > 200) {\n    speed = 200;\n  }\n  return speed;\n};\n\n// ** Mock GPS Generation: Create 5-6 Batches per Day **\nexport const mockGPSData = async (setGpsData, driverId) => {\n  const basePoints = [{\n    Latitude: 26.6338,\n    Longitude: 92.8006\n  },\n  // Point A (Home)\n  {\n    Latitude: 26.6382,\n    Longitude: 92.8074\n  },\n  // Point B (Office)\n  {\n    Latitude: 26.6451,\n    Longitude: 92.8185\n  },\n  // Point C (Market)\n  {\n    Latitude: 26.6492,\n    Longitude: 92.8220\n  } // Point D (Pharmacy)\n  ];\n  const journey = [];\n  const totalBatches = 5; // Total of 5 batches for the day\n\n  for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {\n    let batch = [];\n\n    // Generate random points for each batch (could have 8-10 points per batch)\n    for (let i = 0; i < basePoints.length; i++) {\n      const nextPoint = basePoints[(i + 1) % basePoints.length]; // Loop back to A after D\n      const currentPoint = basePoints[i];\n      let timeStep = generateRandomTimeStep();\n\n      // Generate 3-5 random points between each major stop\n      for (let j = 0; j < 3; j++) {\n        const randomLatLng = generateRandomLatLng(currentPoint.Latitude, currentPoint.Longitude);\n        const speed = calculateSpeed(currentPoint, randomLatLng, timeStep);\n\n        // Ensure valid timeStep and speed before adding to the journey\n        if (speed >= 0 && timeStep > 0) {\n          batch.push({\n            ...randomLatLng,\n            Time_Step: timeStep,\n            Speed: speed\n          });\n          setGpsData(prev => [...prev, {\n            ...randomLatLng,\n            Time_Step: timeStep,\n            Speed: speed\n          }]);\n        }\n        timeStep += generateRandomTimeStep(); // Increment the time step for the next point\n      }\n\n      // Add the final point at the destination (B, C, D, A)\n      const speed = calculateSpeed(currentPoint, nextPoint, timeStep);\n      if (speed >= 0 && timeStep > 0) {\n        batch.push({\n          ...nextPoint,\n          Time_Step: timeStep,\n          Speed: speed\n        });\n        setGpsData(prev => [...prev, {\n          ...nextPoint,\n          Time_Step: timeStep,\n          Speed: speed\n        }]);\n      }\n    }\n\n    // Send the batch after collecting all points for the journey\n    await sendGPSBatchToBackend(batch, driverId);\n\n    // Simulate delay between batches (e.g., simulate multiple batches throughout the day)\n    await new Promise(resolve => setTimeout(resolve, 5000)); // Simulate delay between batches (5 seconds for testing)\n  }\n};\n\n// Helper function to calculate distance between two GPS points (in meters)\nconst calculateDistance = (point1, point2) => {\n  const R = 6371e3; // Radius of the earth in meters\n  const lat1 = point1.Latitude * Math.PI / 180;\n  const lat2 = point2.Latitude * Math.PI / 180;\n  const deltaLat = (point2.Latitude - point1.Latitude) * Math.PI / 180;\n  const deltaLon = (point2.Longitude - point1.Longitude) * Math.PI / 180;\n  const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c; // Returns the distance in meters\n};\n\n// Helper function to calculate time step between two timestamps (in seconds)\nconst calculateTimeStep = (startTime, endTime) => {\n  return Math.floor((endTime - startTime) / 1000); // Return difference in seconds\n};","map":{"version":3,"names":["api","sendGPSBatchToBackend","batch","driverId","token","localStorage","getItem","console","error","response","post","driver_id","gps_data","headers","Authorization","status","log","data","message","generateRandomTimeStep","Math","floor","random","generateRandomLatLng","baseLat","baseLng","distance","randomOffset","Latitude","Longitude","calculateSpeed","point1","point2","timeStep","NaN","calculateDistance","speed","mockGPSData","setGpsData","basePoints","journey","totalBatches","batchIndex","i","length","nextPoint","currentPoint","j","randomLatLng","push","Time_Step","Speed","prev","Promise","resolve","setTimeout","R","lat1","PI","lat2","deltaLat","deltaLon","a","sin","cos","c","atan2","sqrt","calculateTimeStep","startTime","endTime"],"sources":["C:/Users/anush/OneDrive/Desktop/minor project/DriveIQ/DriveIQ/DriveIQ-PWA/src/utils/geolocation.js"],"sourcesContent":["import api from './api';  // Axios instance\r\n\r\n// Helper to send a batch of GPS data to the backend\r\nconst sendGPSBatchToBackend = async (batch, driverId) => {\r\n  try {\r\n    const token = localStorage.getItem('token');  // Get JWT token\r\n    if (!token) {\r\n      console.error('No token found');\r\n      return;\r\n    }\r\n\r\n    const response = await api.post('/record-telematics', {\r\n      driver_id: driverId,\r\n      gps_data: batch,  // Send the batch data\r\n    }, {\r\n      headers: {\r\n        Authorization: `Bearer ${token}`,\r\n      },\r\n    });\r\n\r\n    if (response.status === 200) {\r\n      console.log('Batch successfully sent:', response.data);\r\n    } else {\r\n      console.error('Error sending GPS data. Response:', response);\r\n    }\r\n  } catch (error) {\r\n    console.error('Error sending GPS data:', error.response || error.message || error);\r\n  }\r\n};\r\n\r\n// Function to generate random time steps between 60 and 300 seconds\r\nconst generateRandomTimeStep = () => {\r\n  return Math.floor(Math.random() * (300 - 60 + 1)) + 60;\r\n};\r\n\r\n// Function to generate random lat/long points near a base point\r\nconst generateRandomLatLng = (baseLat, baseLng, distance = 0.01) => {\r\n  const randomOffset = () => (Math.random() - 0.5) * distance;  // Generate small random offset for lat/lng\r\n  return {\r\n    Latitude: baseLat + randomOffset(),\r\n    Longitude: baseLng + randomOffset(),\r\n  };\r\n};\r\n\r\n// Function to calculate speed in km/h between two GPS points based on distance and time step\r\nconst calculateSpeed = (point1, point2, timeStep) => {\r\n  if (timeStep === 0) return NaN;  // Avoid division by zero\r\n\r\n  const distance = calculateDistance(point1, point2);  // Distance in meters\r\n  let speed = (distance / timeStep) * 3.6;  // Convert m/s to km/h\r\n\r\n  // Cap the speed to a realistic value (e.g., max 200 km/h)\r\n  if (speed > 200) {\r\n    speed = 200;\r\n  }\r\n\r\n  return speed;\r\n};\r\n\r\n// ** Mock GPS Generation: Create 5-6 Batches per Day **\r\nexport const mockGPSData = async (setGpsData, driverId) => {\r\n  const basePoints = [\r\n    { Latitude: 26.6338, Longitude: 92.8006 },  // Point A (Home)\r\n    { Latitude: 26.6382, Longitude: 92.8074 },  // Point B (Office)\r\n    { Latitude: 26.6451, Longitude: 92.8185 },  // Point C (Market)\r\n    { Latitude: 26.6492, Longitude: 92.8220 }   // Point D (Pharmacy)\r\n  ];\r\n\r\n  const journey = [];\r\n  const totalBatches = 5;  // Total of 5 batches for the day\r\n\r\n  for (let batchIndex = 0; batchIndex < totalBatches; batchIndex++) {\r\n    let batch = [];\r\n\r\n    // Generate random points for each batch (could have 8-10 points per batch)\r\n    for (let i = 0; i < basePoints.length; i++) {\r\n      const nextPoint = basePoints[(i + 1) % basePoints.length];  // Loop back to A after D\r\n      const currentPoint = basePoints[i];\r\n      let timeStep = generateRandomTimeStep();\r\n\r\n      // Generate 3-5 random points between each major stop\r\n      for (let j = 0; j < 3; j++) {\r\n        const randomLatLng = generateRandomLatLng(currentPoint.Latitude, currentPoint.Longitude);\r\n        const speed = calculateSpeed(currentPoint, randomLatLng, timeStep);\r\n\r\n        // Ensure valid timeStep and speed before adding to the journey\r\n        if (speed >= 0 && timeStep > 0) {\r\n          batch.push({ ...randomLatLng, Time_Step: timeStep, Speed: speed });\r\n          setGpsData(prev => [...prev, { ...randomLatLng, Time_Step: timeStep, Speed: speed }]);\r\n        }\r\n\r\n        timeStep += generateRandomTimeStep();  // Increment the time step for the next point\r\n      }\r\n\r\n      // Add the final point at the destination (B, C, D, A)\r\n      const speed = calculateSpeed(currentPoint, nextPoint, timeStep);\r\n      if (speed >= 0 && timeStep > 0) {\r\n        batch.push({ ...nextPoint, Time_Step: timeStep, Speed: speed });\r\n        setGpsData(prev => [...prev, { ...nextPoint, Time_Step: timeStep, Speed: speed }]);\r\n      }\r\n    }\r\n\r\n    // Send the batch after collecting all points for the journey\r\n    await sendGPSBatchToBackend(batch, driverId);\r\n\r\n    // Simulate delay between batches (e.g., simulate multiple batches throughout the day)\r\n    await new Promise((resolve) => setTimeout(resolve, 5000));  // Simulate delay between batches (5 seconds for testing)\r\n  }\r\n};\r\n\r\n// Helper function to calculate distance between two GPS points (in meters)\r\nconst calculateDistance = (point1, point2) => {\r\n  const R = 6371e3;  // Radius of the earth in meters\r\n  const lat1 = point1.Latitude * Math.PI / 180;\r\n  const lat2 = point2.Latitude * Math.PI / 180;\r\n  const deltaLat = (point2.Latitude - point1.Latitude) * Math.PI / 180;\r\n  const deltaLon = (point2.Longitude - point1.Longitude) * Math.PI / 180;\r\n\r\n  const a = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +\r\n            Math.cos(lat1) * Math.cos(lat2) *\r\n            Math.sin(deltaLon / 2) * Math.sin(deltaLon / 2);\r\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n  return R * c;  // Returns the distance in meters\r\n};\r\n\r\n// Helper function to calculate time step between two timestamps (in seconds)\r\nconst calculateTimeStep = (startTime, endTime) => {\r\n  return Math.floor((endTime - startTime) / 1000);  // Return difference in seconds\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}